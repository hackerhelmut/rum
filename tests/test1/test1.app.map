{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../../rum.macro.coffee",
    "test1.app.coffee",
    "../../module.macro.coffee",
    "../../jade.macro.coffee",
    "mod2.coffee",
    null,
    null,
    "mod1.coffee",
    null,
    "mod2.coffee",
    null,
    null,
    null,
    "test1.template.coffee"
  ],
  "names": [],
  "mappings": ";;;EACA,WAAA,GACE;AAAA,IAAA,MAAA,EAAQ,SAAC,MAAD,EAAS,UAAT,GAAA;AACN,UAAA,cAAA;AAAA,MAAA,IAAA,GAAO,MAAP,CAAA;AACA,MAAA,IAAG,MAAA,CAAO,MAAP,KAAiB,QAApB;AACE,QAAA,IAAA,GAAO,MAAP,CAAA;AAAA,QACA,MAAA,GAAS,WAAY,CAAA,IAAA,CAAZ,IAAqB,EAD9B,CADF;OADA;AAIA,WAAA,iBAAA;8BAAA;AACE,QAAA,MAAO,CAAA,GAAA,CAAP,GAAc,GAAd,CADF;AAAA,OAJA;AAMA,MAAA,IAAG,YAAH;AACE,QAAA,WAAY,CAAA,IAAA,CAAZ,GAAoB,MAApB,CADF;OANA;AAQA,aAAO,MAAP,CATM;IAAA,CAAR;;;ACFF,EC6BM,WAAW,CAAC,MAAM,CAAC,GAAnB,cAAA,IAAA,EO7BC,SAAA,GAAA;AACL,WAAO;AAAA,MACL,IAAA,EAAM,OADD;AAAA,MAEL,QAAA,ECHJ,WAAW,CAAC,QAAQ,CAAC,KAAM,CAAA,eAAA,CDClB;KAAP,CADK;EAAA,CP6BD,CD7BN,CAAA;AAAA,EC6BM,WAAW,CAAC,MAAM,CAAC,GAAnB,cAAA,UAAA,EK7BW,SAAC,IAAD,GAAA;AACf,WAAO;AAAA,MACL,IAAA,EAAM,OADD;AAAA,MAEL,IAAA,EAAM,IAFD;AAAA,MAGL,QAAA,ECJJ,WAAW,CAAC,QAAQ,CAAC,KAAM,CAAA,eAAA,CDClB;KAAP,CADe;EAAA,CL6BX,CD7BN,CAAA;AAAA,EC6BM,WAAW,CAAC,MAAM,CAAC,GAAnB,mBAAA,UAAA,ED7BgB,SAAC,IAAD,GAAA;AAEpB,QAAA,IAAA;AAAA,IAAA,IAAA,GKFF,WAAW,CAAC,MAAM,CAAC,GAAnB,CAAuB,MAAvB,CLEE,CAAA;WACA,OAAO,CAAC,GAAR,CAAY,IAAZ,EAAkB,IAAlB,EAHoB;EAAA,CC6BhB,CD7BN,CAAA;AAAA,EUAA,MAAA,GAAS,WAAW,CAAC,MAAM,CAAC,GAAnB,CAAuB,kBAAvB,CVAT,CAAA;;IWAA,MAAM,CAAE,OAAR,GAAkB",
  "sourcesContent": [
    "# Declare rum runtime base instance\napplication =\n  extend: (object, properties) ->\n    name = undefined\n    if typeof object == 'string'\n      name = object\n      object = application[name] or {}\n    for key, val of properties\n      object[key] = val\n    if name?\n      application[name] = object\n    return object\n\nmacro ->\n# declare rum compiletime base instance\n  path = macro.require 'path'\n  @application =\n    # to extend the base instance with macro modules\n    extend: (object, properties) ->\n      name = undefined\n      if typeof object == 'string'\n        name = object\n        object = @[name] or {}\n      for key, val of properties\n        object[key] = val\n      if name?\n        @[name] = object\n      return object\n\n    path: [path.dirname(macro.file), '.']\n    load: (filename, lang, searchpath) ->\n      fs = macro.require 'fs'\n      filepath = undefined\n      searchpath ?= @path\n      if not lang?\n        lang = 'coffee' if filename.match /\\.coffee$/\n        lang = 'js' if filename.match /\\.js$/\n        lang = 'json' if filename.match /\\.json$/\n        if not lang?\n          lang = \"coffee\"\n\n      for dir in searchpath\n        if fs.existsSync path.join dir, filename\n          filepath = path.join dir, filename\n        else if fs.existsSync path.join dir, \"#{filename}.#{lang}\"\n          filepath = path.join dir, \"#{filename}.#{lang}\"\n      if not filepath?\n        console.error \"File not found: '#{filename}' in serach path:\", searchpath\n        return macro.valToNode '{}'\n\n      code = fs.readFileSync filepath, 'utf8'\n      code = code.substr 1 if code.charCodeAt(0)==0xFEFF\n      if lang == 'js'\n        return macro.jsToNode code\n      else if lang == 'json'\n        return macro.valToNode code\n      else\n        # For some reason we need the macro keyword at least\n        # once in all files which want to process macros\n        code += \"\\nmacro ->\"\n        return macro.bcToNode code, filepath\n\n    callbacks: {}\n\n    bind: (event, callback) ->\n      @callbacks[event] ?= []\n      @callbacks[event].push callback\n\n    unbind: (event, callback) ->\n      if @callbacks[event]? and event in @callbacks[event]\n        @callbacks[event].splice @callbacks[event].indexOf(callback), 1\n\n    trigger: (event, args) ->\n      code = []\n      if @callbacks[event]? and @callbacks[event].length > 0\n        for callback in @callbacks[event]\n          for c in callback args...\n            code.push c\n      return code\n\n# Load components\nmacro ->\n  @application.load \"module.macro\"\n  @application.load \"jade.macro\"\n  @application.trigger 'load.end', []\n\n# The requirejs like define function\nmacro module (args...) ->\n  block = []\n  for code in @application.trigger 'module.begin', args\n    block.push code\n  for code in @application.trigger 'module.end', args\n    block.push code\n  return new macro.Block block\n\nmacro library (args...) ->\n  block = []\n  for code in @application.trigger 'library.begin', args\n    block.push code\n  for code in @application.trigger 'library.end', args\n    block.push code\n  return new macro.Block block\n\nmacro application (args...) ->\n  @application.mainfile = macro.file\n  block = []\n  for code in @application.trigger 'application.begin', args\n    block.push code\n  for code in @application.trigger 'application.end', args\n    block.push code\n  return new macro.Block block\n\n",
    "application ['mod1'], (mod1) ->\n  #Main module\n  mod2 = use 'mod2'\n  console.log mod1, mod2\n\n",
    "###\n RUM Runtime and Module loader and compiletime collector\n###\napplication.extend \"module\",\n  inline: {}\n  add: (name, deps, body) ->\n    @inline[name] =\n      deps: deps\n      body: body\n      inst: undefined\n\n  use: (name) ->\n    if (module = @inline[name])?\n      return module.inst ?= module.body (\n        for dep in module.deps\n          @use dep\n      )...\n    else if require? and typeof require == 'function'\n      return require name\n    else\n      console.log \"Module #{name} \" +\n        \"is not included and no commonjs require is found.\"\n\nmacro ->\n  application = @application\n  @application.extend \"module\",\n    inline: {}\n\n    stub: macro.codeToNode ->\n      application.module.add name, deps, body\n\n    use: (file) ->\n      if not @inline[file]?\n        result = application.load file\n      return file\n\n    def: (args) ->\n      deps = []\n      body = macro.valToNode undefined\n      if args.length == 1\n        body = args[0]\n      else if args.length == 2\n        deps = macro.nodeToVal args[0]\n        body = args[1]\n      else if args.length == 3\n        name = macro.nodeToVal args[0]\n        deps = macro.nodeToVal args[1]\n        body = args[2]\n      else\n        console.error \"define takes a maximum of 3 arguments\"\n      \n      arg = []\n      for dep in deps\n        arg.push @use dep\n      \n      @inline[macro.file] ?= {}\n      @inline[macro.file].deps = arg\n      @inline[macro.file].body = body\n\n    begin: (app) ->\n      code = []\n      for name, module of @inline\n        code.push @stub.subst\n          name: macro.valToNode name\n          deps: macro.valToNode (module.deps or [])\n          body: module.body\n      code.push macro.csToNode \"module = application.module.use \\\"#{app}\\\"\"\n      code.push macro.csToNode \"module?.exports = module\"\n      return code\n\n  # bind on global events\n  @application.bind \"application.begin\", =>\n    @application.module.def arguments\n    @application.module.begin macro.file\n\n  @application.bind \"library.begin\", =>\n    @application.module.def arguments\n    @application.module.begin macro.file\n\n  @application.bind \"module.begin\", =>\n    @application.module.def arguments\n\nmacro use (file) ->\n  if typeof file == 'object'\n    file = macro.nodeToVal file\n  macro.csToNode \"application.module.use \\\"#{@application.module.use file}\\\"\"\n\nmacro define (args...) ->\n  macro.module args...\n\nmacro ->",
    "###\n RUM Jade Template engine integration\n###\n#\napplication.extend \"template\",\n  execute: (template, options) ->\n    return template(options)\n\nmacro ->\n  application = @application\n  @application.extend \"template\",\n    engine: macro.require 'jade'\n    options:\n      pretty: true\n    index: {}\n    define: (template, options) ->\n      name = \"#{macro.file}:#{macro.line}\"\n      application.trigger \"application.template.define\", name, template\n      @index[name] = macro.nodeToVal template\n      return macro.csToNode \"application.template.index[\\\"#{name}\\\"]\"\n\n    list: (old) ->\n      result = \"\"\n      if Object.keys(@index).length != 0\n        result = \"compileTemplate\\n\"\n        for name, template of @index\n          if old[name]?\n            template = old[name]\n            delete old[name]\n          result += \"  '#{name}': '''\\n#{template.replace /^/gm, \"    \"}\\n  '''\\n\"\n      if Object.keys(old).length != 0\n        result += \"  # Old templates not found in the current build\\n\"\n        result += \"  # Have a look at the templates they might just\\n\"\n        result += \"  # have been moved.\\n\"\n\n        for name, template of old\n          result += \"  '#{name}': '''\\n#{template.replace /^/gm, \"    \"}\\n  '''\\n\"\n      return result\n\n    compile: (templates) ->\n      return new macro.Block (for name, template of templates\n        macro.jsToNode \"application.template.index[#{name}] = #{@engine.compile(template, @options)};\"\n      )\n\n  @application.bind \"application.end\", =>\n    fs = macro.require 'fs'\n    path = macro.require 'path'\n    for name, file of flags\n      if name == \"template\"\n        #if fs.existsSync file\n        old = macro.nodeToVal application.load \"test1.template.coffee\", \"coffee\", [\".\"]\n        data = @application.template.list old\n        fs.writeFileSync(file, data)\n    return []\n\nmacro defineTemplate (template) ->\n  @application.template.define template\n\nmacro compileTemplate (template) ->\n  if not @application.mainfile?\n    @application.template.compile template\n  else\n    console.log @application.mainfile\n    return template\n\nmacro executeTemplate (template, options) ->\n  @application.template.execute template, options\n\nmacro ->",
    "module ->\n  return {\n    mod2: \"Check\"\n    template: defineTemplate '''\n      h1 Hello World\n      p Module 2 sends his regards\n        a(href=\"#\") with link\n    '''\n  }\n\nmacro ->",
    "application.template.index[\"mod2.coffee:4\"]",
    "application.module.use \"mod2\"",
    "module ['mod2'], (mod2) ->\n  return {\n    mod1: \"Check\"\n    mod2: mod2\n    template: defineTemplate '''\n      h1 Hello World\n      p This is a test\n        a(href=\"#\") with link\n    '''\n  }\n\nmacro ->",
    "application.template.index[\"mod1.coffee:5\"]",
    "module ->\n  return {\n    mod2: \"Check\"\n    template: defineTemplate '''\n      h1 Hello World\n      p Module 2 sends his regards\n        a(href=\"#\") with link\n    '''\n  }\n\nmacro ->",
    "application.template.index[\"mod2.coffee:4\"]",
    "module = application.module.use \"test1.app.coffee\"",
    "module?.exports = module",
    "compileTemplate\n  'mod2.coffee:4': '''\n    h1 Hello World\n    p Module 2 sends his regards\n      a(href=\"#\") with link\n  '''\n  'mod1.coffee:5': '''\n    h1 Hello World\n    p This is a test\n      a(href=\"#\") with link\n  '''\n  # Old templates not found in the current build\n  # Have a look at the templates they might just\n  # have been moved.\n  'mod2.coffee:42': '''\n    h1 Hello World\n    p Module 2 sends his regards\n      a(href=\"#\") with link\n  '''\n\nmacro ->"
  ]
}